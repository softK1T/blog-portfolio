import {
  collection,
  addDoc,
  getDocs,
  getDoc,
  doc,
  updateDoc,
  deleteDoc,
  query,
  orderBy,
  where,
  limit,
  Timestamp,
} from "firebase/firestore";
import { db } from "./firebase";
import { handleError } from "./utils";

/**
 * Media item interface for storing file metadata.
 * Used for images and videos attached to posts, logs, and projects.
 */
export interface MediaItem {
  /** S3 object key (file path in bucket) */
  key: string;
  /** Media type classification */
  type: "image" | "video";
  /** Optional caption for the media */
  caption?: string;
}

/**
 * Portfolio project interface representing a showcase project.
 * Contains all metadata needed to display a project in the portfolio.
 */
export interface PortfolioItem {
  /** Unique identifier (auto-generated by Firestore) */
  id?: string;
  /** Project title/name */
  title: string;
  /** Brief project description for previews and cards */
  description: string;
  /** Full project content with markdown support for detailed view */
  content?: string;
  /** List of technologies used in the project */
  technologies: string[];
  /** GitHub repository URL */
  githubLink?: string;
  /** Live demo URL */
  liveLink?: string;
  /** Legacy image URL field (deprecated, use media array instead) */
  imageUrl?: string;
  /** Array of media files (images/videos) for the project */
  media?: MediaItem[];
  /** Whether the project should be featured on the homepage */
  featured: boolean;
  /** Whether the project is published and visible to visitors */
  published: boolean;
  /** Creation timestamp */
  createdAt: Date;
  /** Last update timestamp */
  updatedAt: Date;
  /** Associated development logs (populated when needed) */
  developmentLogs?: DevelopmentLog[];
}

/**
 * Blog post interface for development articles and insights.
 * Supports rich content, tagging, and media attachments.
 */
export interface BlogPost {
  /** Unique identifier (auto-generated by Firestore) */
  id?: string;
  /** Post title */
  title: string;
  /** Full post content (supports markdown) */
  content: string;
  /** Brief summary for previews and SEO */
  summary: string;
  /** Tags for categorization and filtering */
  tags: string[];
  /** Legacy image URL field (deprecated, use media array instead) */
  imageUrl?: string;
  /** Array of media files (images/videos) for the post */
  media?: MediaItem[];
  /** Whether the post is published and visible to visitors */
  published: boolean;
  /** Creation timestamp */
  createdAt: Date;
  /** Last update timestamp */
  updatedAt: Date;
  /** Optional link to a specific project */
  projectId?: string;
}

/**
 * Development log interface for tracking project progress.
 * Used to document milestones, features, bug fixes, and learnings.
 */
export interface DevelopmentLog {
  /** Unique identifier (auto-generated by Firestore) */
  id?: string;
  /** Associated project ID */
  projectId: string;
  /** Log entry title */
  title: string;
  /** Detailed log content */
  content: string;
  /** Type of development activity */
  type: "milestone" | "bug-fix" | "feature" | "optimization" | "learning";
  /** Date of the development activity */
  date: Date;
  /** Tags for categorization */
  tags: string[];
  /** Array of media files (screenshots, videos, etc.) */
  media?: MediaItem[];
  /** Whether the log is published and visible to visitors */
  published: boolean;
  /** Creation timestamp */
  createdAt: Date;
  /** Last update timestamp */
  updatedAt: Date;
}

/**
 * Portfolio service for managing portfolio projects.
 * Provides CRUD operations for portfolio items with Firestore integration.
 */
export const portfolioService = {
  /**
   * Adds a new portfolio project to the database.
   *
   * @param project - Project data without id, createdAt, and updatedAt fields
   * @returns Promise resolving to the new project's ID
   * @throws {Error} When project creation fails
   *
   * @example
   * ```ts
   * const projectId = await portfolioService.addProject({
   *   title: "My Project",
   *   description: "A great project",
   *   technologies: ["React", "Node.js"],
   *   featured: true,
   *   published: true
   * });
   * ```
   */
  async addProject(
    project: Omit<PortfolioItem, "id" | "createdAt" | "updatedAt">
  ): Promise<string> {
    try {
      const docRef = await addDoc(collection(db, "portfolio"), {
        ...project,
        createdAt: Timestamp.now(),
        updatedAt: Timestamp.now(),
      });
      return docRef.id;
    } catch (error) {
      throw handleError(error, "Error adding project");
    }
  },

  /**
   * Retrieves published portfolio projects, optionally limited by count.
   * Projects are sorted by creation date (newest first).
   *
   * @param limitCount - Optional limit on the number of projects to return
   * @returns Promise resolving to array of portfolio projects
   * @throws {Error} When fetching projects fails
   *
   * @example
   * ```ts
   * const projects = await portfolioService.getProjects(5); // Get 5 most recent
   * const allProjects = await portfolioService.getProjects(); // Get all published
   * ```
   */
  async getProjects(limitCount?: number): Promise<PortfolioItem[]> {
    try {
      let q = query(
        collection(db, "portfolio"),
        where("published", "==", true),
        orderBy("createdAt", "desc")
      );

      if (limitCount) {
        q = query(q, limit(limitCount));
      }

      const querySnapshot = await getDocs(q);

      const projects = querySnapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
        createdAt: doc.data().createdAt.toDate(),
        updatedAt: doc.data().updatedAt.toDate(),
      })) as PortfolioItem[];

      return projects;
    } catch (error) {
      throw handleError(error, "Error fetching projects");
    }
  },

  /**
   * Retrieves all portfolio projects (both published and unpublished).
   * Used for admin purposes to manage all projects.
   *
   * @returns Promise resolving to array of all portfolio projects
   * @throws {Error} When fetching projects fails
   */
  async getAllProjects(): Promise<PortfolioItem[]> {
    try {
      const querySnapshot = await getDocs(
        query(collection(db, "portfolio"), orderBy("createdAt", "desc"))
      );

      const projects = querySnapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
        createdAt: doc.data().createdAt.toDate(),
        updatedAt: doc.data().updatedAt.toDate(),
      })) as PortfolioItem[];

      return projects;
    } catch (error) {
      throw handleError(error, "Error fetching all projects");
    }
  },

  /**
   * Retrieves a specific portfolio project by ID.
   *
   * @param id - The project's unique identifier
   * @returns Promise resolving to the project or null if not found
   * @throws {Error} When fetching the project fails
   *
   * @example
   * ```ts
   * const project = await portfolioService.getProject("project123");
   * if (project) {
   *   console.log(project.title);
   * }
   * ```
   */
  async getProject(id: string): Promise<PortfolioItem | null> {
    try {
      const docRef = doc(db, "portfolio", id);
      const docSnap = await getDoc(docRef);

      if (docSnap.exists()) {
        return {
          id: docSnap.id,
          ...docSnap.data(),
          createdAt: docSnap.data().createdAt.toDate(),
          updatedAt: docSnap.data().updatedAt.toDate(),
        } as PortfolioItem;
      }

      return null;
    } catch (error) {
      throw handleError(error, "Error fetching project");
    }
  },

  /**
   * Updates an existing portfolio project.
   *
   * @param id - The project's unique identifier
   * @param updates - Partial project data to update
   * @returns Promise that resolves when update is complete
   * @throws {Error} When update fails
   *
   * @example
   * ```ts
   * await portfolioService.updateProject("project123", {
   *   title: "Updated Title",
   *   featured: true
   * });
   * ```
   */
  async updateProject(
    id: string,
    updates: Partial<PortfolioItem>
  ): Promise<void> {
    try {
      const docRef = doc(db, "portfolio", id);
      await updateDoc(docRef, {
        ...updates,
        updatedAt: Timestamp.now(),
      });
    } catch (error) {
      throw handleError(error, "Error updating project");
    }
  },

  /**
   * Deletes a portfolio project permanently.
   *
   * @param id - The project's unique identifier
   * @returns Promise that resolves when deletion is complete
   * @throws {Error} When deletion fails
   *
   * @example
   * ```ts
   * await portfolioService.deleteProject("project123");
   * ```
   */
  async deleteProject(id: string): Promise<void> {
    try {
      const docRef = doc(db, "portfolio", id);
      await deleteDoc(docRef);
    } catch (error) {
      throw handleError(error, "Error deleting project");
    }
  },
};

/**
 * Blog service for managing blog posts.
 * Provides CRUD operations for blog posts with Firestore integration.
 */
export const blogService = {
  /**
   * Adds a new blog post to the database.
   *
   * @param post - Post data without id, createdAt, and updatedAt fields
   * @returns Promise resolving to the new post's ID
   * @throws {Error} When post creation fails
   *
   * @example
   * ```ts
   * const postId = await blogService.addPost({
   *   title: "My Blog Post",
   *   content: "# Hello World\nThis is my post content...",
   *   summary: "A brief summary",
   *   tags: ["React", "Next.js"],
   *   published: true
   * });
   * ```
   */
  async addPost(
    post: Omit<BlogPost, "id" | "createdAt" | "updatedAt">
  ): Promise<string> {
    try {
      const docRef = await addDoc(collection(db, "blog"), {
        ...post,
        createdAt: Timestamp.now(),
        updatedAt: Timestamp.now(),
      });
      return docRef.id;
    } catch (error) {
      throw handleError(error, "Error adding blog post");
    }
  },

  /**
   * Retrieves published blog posts, optionally limited by count.
   * Posts are sorted by creation date (newest first).
   *
   * @param limitCount - Optional limit on the number of posts to return
   * @returns Promise resolving to array of blog posts
   * @throws {Error} When fetching posts fails
   *
   * @example
   * ```ts
   * const posts = await blogService.getPosts(3); // Get 3 most recent
   * const allPosts = await blogService.getPosts(); // Get all published
   * ```
   */
  async getPosts(limitCount?: number): Promise<BlogPost[]> {
    try {
      let q = query(
        collection(db, "blog"),
        where("published", "==", true),
        orderBy("createdAt", "desc")
      );

      if (limitCount) {
        q = query(q, limit(limitCount));
      }

      const querySnapshot = await getDocs(q);

      const posts = querySnapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
        createdAt: doc.data().createdAt.toDate(),
        updatedAt: doc.data().updatedAt.toDate(),
      })) as BlogPost[];

      return posts;
    } catch (error) {
      throw handleError(error, "Error fetching blog posts");
    }
  },

  /**
   * Retrieves all blog posts (both published and unpublished).
   * Used for admin purposes to manage all posts.
   *
   * @returns Promise resolving to array of all blog posts
   * @throws {Error} When fetching posts fails
   */
  async getAllPosts(): Promise<BlogPost[]> {
    try {
      const querySnapshot = await getDocs(
        query(collection(db, "blog"), orderBy("createdAt", "desc"))
      );

      const posts = querySnapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
        createdAt: doc.data().createdAt.toDate(),
        updatedAt: doc.data().updatedAt.toDate(),
      })) as BlogPost[];

      return posts;
    } catch (error) {
      throw handleError(error, "Error fetching all blog posts");
    }
  },

  /**
   * Retrieves blog posts associated with a specific project.
   *
   * @param projectId - The project's unique identifier
   * @returns Promise resolving to array of blog posts for the project
   * @throws {Error} When fetching posts fails
   *
   * @example
   * ```ts
   * const projectPosts = await blogService.getPostsByProject("project123");
   * ```
   */
  async getPostsByProject(projectId: string): Promise<BlogPost[]> {
    try {
      const querySnapshot = await getDocs(
        query(
          collection(db, "blog"),
          where("projectId", "==", projectId),
          where("published", "==", true),
          orderBy("createdAt", "desc")
        )
      );

      const posts = querySnapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
        createdAt: doc.data().createdAt.toDate(),
        updatedAt: doc.data().updatedAt.toDate(),
      })) as BlogPost[];

      return posts;
    } catch (error) {
      throw handleError(error, "Error fetching blog posts by project");
    }
  },

  /**
   * Retrieves a specific blog post by ID.
   *
   * @param id - The post's unique identifier
   * @returns Promise resolving to the post or null if not found
   * @throws {Error} When fetching the post fails
   *
   * @example
   * ```ts
   * const post = await blogService.getPost("post123");
   * if (post) {
   *   console.log(post.title);
   * }
   * ```
   */
  async getPost(id: string): Promise<BlogPost | null> {
    try {
      const docRef = doc(db, "blog", id);
      const docSnap = await getDoc(docRef);

      if (docSnap.exists()) {
        return {
          id: docSnap.id,
          ...docSnap.data(),
          createdAt: docSnap.data().createdAt.toDate(),
          updatedAt: docSnap.data().updatedAt.toDate(),
        } as BlogPost;
      }

      return null;
    } catch (error) {
      throw handleError(error, "Error fetching blog post");
    }
  },

  /**
   * Updates an existing blog post.
   *
   * @param id - The post's unique identifier
   * @param updates - Partial post data to update
   * @returns Promise that resolves when update is complete
   * @throws {Error} When update fails
   *
   * @example
   * ```ts
   * await blogService.updatePost("post123", {
   *   title: "Updated Title",
   *   published: true
   * });
   * ```
   */
  async updatePost(id: string, updates: Partial<BlogPost>): Promise<void> {
    try {
      const docRef = doc(db, "blog", id);
      await updateDoc(docRef, {
        ...updates,
        updatedAt: Timestamp.now(),
      });
    } catch (error) {
      throw handleError(error, "Error updating blog post");
    }
  },

  /**
   * Deletes a blog post permanently.
   *
   * @param id - The post's unique identifier
   * @returns Promise that resolves when deletion is complete
   * @throws {Error} When deletion fails
   *
   * @example
   * ```ts
   * await blogService.deletePost("post123");
   * ```
   */
  async deletePost(id: string): Promise<void> {
    try {
      const docRef = doc(db, "blog", id);
      await deleteDoc(docRef);
    } catch (error) {
      throw handleError(error, "Error deleting blog post");
    }
  },
};

/**
 * Development log service for managing project development logs.
 * Provides CRUD operations for development logs with Firestore integration.
 */
export const developmentLogService = {
  /**
   * Adds a new development log entry to the database.
   *
   * @param log - Log data without id, createdAt, and updatedAt fields
   * @returns Promise resolving to the new log's ID
   * @throws {Error} When log creation fails
   *
   * @example
   * ```ts
   * const logId = await developmentLogService.addLog({
   *   projectId: "project123",
   *   title: "Implemented User Authentication",
   *   content: "Added Firebase Auth integration...",
   *   type: "feature",
   *   date: new Date(),
   *   tags: ["auth", "firebase"],
   *   published: true
   * });
   * ```
   */
  async addLog(
    log: Omit<DevelopmentLog, "id" | "createdAt" | "updatedAt">
  ): Promise<string> {
    try {
      const docRef = await addDoc(collection(db, "developmentLogs"), {
        ...log,
        createdAt: Timestamp.now(),
        updatedAt: Timestamp.now(),
      });
      return docRef.id;
    } catch (error) {
      throw handleError(error, "Error adding development log");
    }
  },

  /**
   * Retrieves development logs for a specific project.
   * Logs are sorted by date (newest first).
   *
   * @param projectId - The project's unique identifier
   * @returns Promise resolving to array of development logs
   * @throws {Error} When fetching logs fails
   *
   * @example
   * ```ts
   * const logs = await developmentLogService.getLogsByProject("project123");
   * ```
   */
  async getLogsByProject(projectId: string): Promise<DevelopmentLog[]> {
    try {
      const querySnapshot = await getDocs(
        query(
          collection(db, "developmentLogs"),
          where("projectId", "==", projectId),
          where("published", "==", true),
          orderBy("date", "desc")
        )
      );

      const logs = querySnapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
        date: doc.data().date.toDate(),
        createdAt: doc.data().createdAt.toDate(),
        updatedAt: doc.data().updatedAt.toDate(),
      })) as DevelopmentLog[];

      return logs;
    } catch (error) {
      throw handleError(error, "Error fetching development logs by project");
    }
  },

  /**
   * Retrieves a specific development log by ID.
   *
   * @param id - The log's unique identifier
   * @returns Promise resolving to the log or null if not found
   * @throws {Error} When fetching the log fails
   *
   * @example
   * ```ts
   * const log = await developmentLogService.getLog("log123");
   * if (log) {
   *   console.log(log.title);
   * }
   * ```
   */
  async getLog(id: string): Promise<DevelopmentLog | null> {
    try {
      const docRef = doc(db, "developmentLogs", id);
      const docSnap = await getDoc(docRef);

      if (docSnap.exists()) {
        return {
          id: docSnap.id,
          ...docSnap.data(),
          date: docSnap.data().date.toDate(),
          createdAt: docSnap.data().createdAt.toDate(),
          updatedAt: docSnap.data().updatedAt.toDate(),
        } as DevelopmentLog;
      }

      return null;
    } catch (error) {
      throw handleError(error, "Error fetching development log");
    }
  },

  /**
   * Updates an existing development log.
   *
   * @param id - The log's unique identifier
   * @param updates - Partial log data to update
   * @returns Promise that resolves when update is complete
   * @throws {Error} When update fails
   *
   * @example
   * ```ts
   * await developmentLogService.updateLog("log123", {
   *   title: "Updated Title",
   *   published: true
   * });
   * ```
   */
  async updateLog(id: string, updates: Partial<DevelopmentLog>): Promise<void> {
    try {
      const docRef = doc(db, "developmentLogs", id);
      await updateDoc(docRef, {
        ...updates,
        updatedAt: Timestamp.now(),
      });
    } catch (error) {
      throw handleError(error, "Error updating development log");
    }
  },

  /**
   * Deletes a development log permanently.
   *
   * @param id - The log's unique identifier
   * @returns Promise that resolves when deletion is complete
   * @throws {Error} When deletion fails
   *
   * @example
   * ```ts
   * await developmentLogService.deleteLog("log123");
   * ```
   */
  async deleteLog(id: string): Promise<void> {
    try {
      const docRef = doc(db, "developmentLogs", id);
      await deleteDoc(docRef);
    } catch (error) {
      throw handleError(error, "Error deleting development log");
    }
  },
};
